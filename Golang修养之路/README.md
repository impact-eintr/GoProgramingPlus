## GMP模型
### 概览
- G goroutine 协程
- P Processor 处理器
- M Thread 内核线程

> 全局队列
存放等待执行的G

> P的本地队列
- 存放等待运行的G
- 数量限制 不超过256个
- 优先将新创建的G 放到本地队列中，如果满了会放在全局队列中

> P列表(P的队列集合)
- 程序启动时创建
- 最多有GOMAXPROCS个

> M列表
当前操作系统分配到当前Go程序的内核线程数

> P 和 M 的数量
- P
  - $GOMAXPROCS
  - runtime.GOMAXPROCS()
- M 
  - Go语言本身限制10000
  - runtime.debug 中SetMaxThreads()
  - 有一个M阻塞就会创建一个新的M
  - 如果有M空闲，就会回收或者睡眠
### 调度策略
- 复用线程
- 利用并行
- 抢占
- 全局G队列

> 复用线程 
- work stealing 机制
比如有两个M和两个P，其中一个P中有多个G，而另一个P中没有G，为了让M不空闲，平会从另一个P的runq的队尾获取一个G。
- hand off 机制
如果当前在M运行的G阻塞了，调度器会创建或者唤醒一个thread作为新的M,将当前M上的P移动到新的M上，而阻塞的G仍然占用M,并进入休眠/销毁

> 利用并行
GOMAXPROCS

> 抢占 
- co-routine 一个c(co-routine)除非主动释放cpu，否则其他等待的c永远无法获取cpu
- goroutine 一个G在cpu上最多运行10ms,到时间就会被调度器踢开，其他G会抢占cpu

> 全局G队列
先从全局队列中获取，没有的话再从其他P的runq中steal


### 流程(重要)
1. 我们通过go func() 来创建一个goroutine
2. 有两个存储G的队列，一个是局部调度器P的本地队列，一个是全局G队列，新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中
3. G只能运行在M中，一个M必须持有一个P，M与P是1:1的关系，M会从P的本地队列中弹出一个可执行状态的G来执行，如果P的本地队列为空，先获取全局队列的G，然后从其他P中steal
4. 一个M调度G执行的过程是一个循环机制
5. 当M执行某个G的时候如果发生了syscall或者其他阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除，然后再创建一个新的操作系统线程(如果有空闲的线程可以使用空闲的线程来服务这个P)
6. 当M系统调用结束的时候，这个G会尝试获取一个空闲的P来执行，并放到这个P的本地队列中，如果获取不到P那么这个线程M会变成休眠状态，加入空闲线程中，然后这个G会被放到全局队列中

### 生命周期
#### M0
- 启动程序后的编号为0的主主线程
- 在全局变量runtime.M0中，不需要在堆上分配
- 负责执行和初始化操作的启动第一个G
- 启动第一个G之后，M0就和其他的M一样了

#### G0
- 每次启动一个M,都会第一个创建的goroutine,就是G0
- G0仅用于负责调度的G
- G0不指向任何可执行的函数
- 每个M都会有一个自己的G0
- 在调度或系统调用时M会切换到G0，来调度goroutine
- M的G0会放在全局空间中

### 场景分析

#### 创建G
两个M执行G1,G2,现在要创建G3,根据局部性，G2优先加入G1所在本地队列(自产自销)

#### G1执行完毕
G1调用goexit()，M1切换为自己的G0(G0负责调度协程切换schdule()函数)，从P的本地队列中获取G2，并开始运行G2函数，实现了线程M1的复用

#### 连续创建多个G,导致队列满
G2创建6个G，假设本地队列最多为4个已满，接下来g2创建G7，将本地队列的前一半G打乱顺序和新创建的G7一同放到全局队列中，G2创建G8，G8加入到P1的本地队列

#### 唤醒正在休眠的M
在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行
假定G2唤醒了M2，M2绑定了P2，并运行了G0，但P2本地队列中没有G，M2现在被称为自选线程(没有G但为运行状态的线程，不断寻找G)

#### 被唤醒的M从全局取得G
M2尝试从全局队列中取一批G放到P2的本地队列，M2从全局队列取出G的数量符合下面的公式

``` go
n = min(len(GQ)/GOMAXPROCS+1, len(GQ/2))
```
1. M2自选线程会寻找可运行的G(优先全局，然后steal)
2. M2从全局队列中获取G3
3. M2完成从G0切换到G3，不再是自旋状态

#### 偷取G的情况
全局队列中已经没有G，那m就要执行work stealing 从其他有G的P那里偷取一半G过来，放在自己的P本地队列中。

#### 自选线程的最大限制
自旋线程+执行线程 <= GOMAXPROCS

#### 发生阻塞调用
G8创建G9 并且G8进行系统调用
M2系统调用中
P2空闲的M5绑定通过G0切换到G9并执行

#### G的阻塞结束
G8创建完G9后阻塞，M与P分离，等阻塞结束后，寻找P，先找原来的，再找全局空闲的，最后放弃，G和M回到全局队列

